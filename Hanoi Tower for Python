#汉诺塔问题 

'''
汉诺塔问题是一个经典的递归问题，代码实现早已有先例可寻。
囿于个人能力，我想不出什么新点子，对递归的理解总是很虚，现成的注释都看不懂。
于是乎，我试图结合Python函数调用的逻辑，把一行行代码同现实中的操作相对应，用最朴素的话给这一经典问题再做一次注释，以此加深对递归的认识。
'''

'''
汉诺塔问题的难点在于要按序摆放圆盘，大的圆盘不能放到小的上面。
这使得我们移动圆盘的时候感到束手束脚，当n较大的时候，顺序推演很快就遇到了瓶颈——可能性太多了。
所谓正难则反，我们倒过来想。
最大的圆盘无法放在任何一个其他圆盘的上方，那么当我们能够移动它时，场面上一定是：

 A->只剩下最大的圆盘 
 B->按序排列着其他所有圆盘 
 C->空着

一旦最大的圆盘移动就位，那么我们就可以视其为不存在，因为其他所有圆盘都比它小，移动不会因它产生障碍。
Ps:这里透露出一点辩证法的思想，所谓“限制”，经过转化，完全可以变成有利条件，帮助简化问题。
'''

'''
此时我们再次审视场上的局面：

A->空着
B->按序排列着(n-1)个圆盘
C->最大的圆盘/空着

我们完全可以说，问题重复了它自己，把B视为起始，A视为缓冲，那么这就是(n-1)时的情况。
换言之，要解决n时的情况，就要解决(n-1)时的情况。
开始了，套娃游戏开始了(
要解决(n-1)时的情况，就要解决(n-2)时的情况。
...
要解决n=2时的情况，就要解决n=1时的情况。
n=1时的情况怎么解决？
？？？
不就是A -> C。
噫，好，我明白了！

刚才的一串思维练习，就是在寻找解决问题的通法，
当我们解决完一层后，我们得到是规模更小并且适用于同样方法的问题，
当n=1时的A->C,就是递归终止的条件，
此时问题的规模已经足够小，以至于我们只需要一步移动便可解决。
'''

'''
以上顶多是完成了一个简单的流程图，对于如何用代码还原这个情景并且解决它，还远远没有涉及。
既然要用到递归，我们首先得明白Python中递归是怎么运作的。(个人摸索得出的一点经验，原理上有误请见谅)
以下面的代码举例：

def move(n,a,b,c):                         
    if n == 1:                             
        print("%s %d move to %s" %(a,n,c)) 
    else:                                  
        move(n-1,a,c,b)                    ......Ⅰ
        print("%s %d move to %s" %(a,n,c)) ......Ⅱ
        move(n-1,b,a,c)                    ......Ⅲ

当n>2时，很自然函数运行到了语句Ⅰ，
很好，move(n,A,B,C)变成了move(n-1,A,C,B)。
然后，是先放下move(n-1,A,C,B)，开始执行语句Ⅱ，还是先不执行语句Ⅱ，并再次调用move()，执行move(n-1，A，C，B)呢？

这个问题困扰了我很久，我在实际的调试中才明白：
Python是解释型语言，解释一句执行一句。
当语句Ⅰ要求再次调用函数move()时，这一行实际上根本没有执行完，
结果还没有算完，如何能继续下去呢？
同样的，如果n>2，重复一次还得不到结果，
那就继续下去，再次调用move()函数。
此时，所有层级里的语句Ⅱ和语句Ⅲ都还在，只不过要等待语句Ⅰ执行完毕了（也就是n=1终止递归时)，才轮到最底层的语句Ⅱ开始执行。

举例说明，当n=2时，运行程序，得到如下结果(数字代表圆盘的大小，1即最上面最小的圆盘）：

A 1 move to B  ... 第一遍n=2进入else的分支，再次调用move(),move(1,A,C,B)
                   此时n=1，进入if n == 1的分支，a=A,n=1,c=B
                   Ps:注意a,b,c只是变量的名字，它的值由move()函数中对应地方的值确定，即a就等于调用函数时第二个输入的str
                   所以打印 A 1 move to B
A 2 move to C  ... 语句Ⅰ彻彻底底执行完毕，里面所有的弯弯绕都和外部无关
                   程序顺着解释语句Ⅱ，此时很显然，它是原始调用move(2,A,B,C)的语句Ⅱ(因为语句Ⅰ减了一次就走到另一个分支去了)
                   此时a=A,n=2,c=B 
                   所以打印 A 2 move to C
B 1 move to C  ... 语句Ⅱ执行完毕，解释语句Ⅲ，和语句Ⅰ的情况相同，再次调用move(),move(1,B,A,C)
                   此时n=1，进入if n == 1的分支，a=B,n=1,c=C
                   所以打印 B 1 move to C

程序执行完毕，结果正确。
'''

'''
为了便于理解，我使用的是最直观的n=2时的情况举例，
n>2时也是同理，只是分层更多，更复杂，但是没有再往下深究的必要了，
因为使用的是现成的代码，我们还没有讨论为什么a,b,c三个字母就那样排列组合了，
还抽象的代码以具象，
是理解这个程序的点睛之笔。
'''

def move(n,a,b,c):                         # 之前的思考中，我们已经设想到会出现“坐标反转”的情况，即推导到(n-1)情况时，B变成了起始，A变成了缓冲
                                           # 当我们意识到“坐标反转”的可能时，就应该明白所谓 A是起始 B是缓冲 C是目标 只是初始情况。递归的过程中，A可能是起始也可能是缓冲。
                                           # def move(n,a,b,c)中的a、b、c的作用实际上是象征，a的那个位置 代表 起始; b的那个位置 代表 缓冲; c的那个位置 代表 目标
                                           # 初始调用时，我们规定A是起始 B是缓冲 C是目标，所以 a='A',b='B',c='C'
                                           # 此时a,b,c已经被赋上了值，有了所指
                                           # 但是要记住，有象征作用的是那个参数的位置，即使def move(n,a,b,c)在调用时a的位置出现的是b，也不要感到迷惑,
                                           # 这时b等价于一个具体的大写A\B\C,
                                           # 这条语句的这个位置表达的意思没有改变，即把 A\B\C 作为 起始                               
                                           
                                          
    if n == 1:
        print("%s %d move to %s" %(a,n,c)) # 现实中的移动操作以print来实现，所谓移动就是由起点到目标地，所以print就是"a move to c"  
                                           
    else:
        move(n-1,a,c,b)                    # move(n-1,a,c,b)的含义翻译出来其实就是，为了让n个圆盘从起始柱A移动到目标柱C
                                           # 我们必须先让前(n-1)个圆盘把缓冲柱B当作它们的目标柱移动过去
                                           # 这一行包含的全部操作即前(n-1)个圆盘移动到柱B所需的操作
        print("%s %d move to %s" %(a,n,c)) # 完成了上面的操作，下一步很明显就是把那最下的第n个圆盘移动到目标柱C
        move(n-1,b,a,c)                    # 问题由n削减至(n-1)，这一句就是一个“坐标反转”，再来一次的过程

def main():                                # 分析到这，我们可以得出结论，else里的每一步，和我们之前的思考对应的很完美
    x = int(input("请输入汉诺塔的层数："))  # 移走(n-1)个到缓冲区，移走最大的到目标区，反转坐标，如法炮制，直至到最简单n=1的那一步
                                           # 看着这行代码，我们可能会想：这是怎么做到的呢，那(n-1)个圆盘移动的具体过程，明明没写出来啊
                                           # 没错，但这就是递归，它并不关心具体的移动过程，我们找到了解决这个问题的通法
                                           # 每一层问题的解决都依赖于下一层问题的解决，我们又的确解决了最底层的问题，那么这个过程就理所当然的成立。
                                           # 还记得正难则反吗？我们是从最大的那个圆盘开始倒序思考的，而程序真正的执行实际上也是倒着的(A 1 move to X)
                                           # So，负负得正，当然结果就是我们想要的啦~
                                           # By the way，理解了那个移动的过程就是print，所以想要计算移动的步数，只要在print下+1就完事了。
    move(x,a='A',b='B',c='C')
                                           # 一口气写了这么多，花了我好几个小时😂
if __name__ == '__main__':                 # 为了思考清楚这个程序的内涵，我着实是头疼了一阵。
    main()                                 # 本就是照猫画虎，有样学样，所以牵强附会，理解不到位的地方肯定是有的。嗐，就这样吧。I am too vegetable.
